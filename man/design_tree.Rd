% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/design_tree.R
\name{design_tree}
\alias{design_tree}
\title{Organize the data around the rooted binary weighted tree}
\usage{
design_tree(Y, leaf_ids, mytree, weighted_edge = FALSE, Z_obs = NULL)
}
\arguments{
\item{Y}{\code{N} by \code{J} binary data matrix; rows for subjects; columns
for binary measurements/features}

\item{leaf_ids}{Character string for leaf nodes for each observation}

\item{mytree}{a tree (an \code{igraph} object) that contains the node,
edge, edge-length ("weight") information.}

\item{weighted_edge}{logical: \code{TRUE} for using the branch lengths then
the \code{mytree} must have this info; if \code{FALSE}, every edge, including
an imaginary edge leading to the root node, is set to have length \code{1}.}

\item{Z_obs}{Default is \code{NULL}; A two-column matrix of (id, class indicator);
the number of rows equals the number of observations;
an entry of 2nd column is \code{NA} if the subject
in that row has an unknown class indicator.
Importantly, the rows will be reordered according to the reordered \code{Y}.}
}
\value{
A list of data and tree information for model fitting
\itemize{
\item \code{Y} A matrix of \code{N} by \code{J}; binary measurements with rows ordered by
leaf groups  (\code{leaf_ids}).
\item \code{A} A matrix of \code{p} by \code{p}; each column contains some \code{1}s, indicating
the node in that column is an ancestor of the node represented in the row.
Ancestor of a node include that node itself.
\item \code{A_leaves} A matrix of \code{pL} by \code{p}; A submatrix of \code{A} that represents
the ancestor matrix but only for leaves
\item \code{leaf_ids} A vector of \code{N}integers; ordered by the leaves as
specified by \code{mytree}.
\item \code{leaf_ids_units} A list of length \code{pL}, each element
is a vector of subject ids belonging to each leaf node
\item \code{leaf_ids_nodes} a list of length \code{p}, each element
is a vector of integers (between \code{1} and \code{pL}; id
is only for leaf nodes) indicating the leaf nodes.
\item \code{ancestors} a list of length \code{pL},
each element is the vector of ancestors (between \code{1} and \code{p}; id is among
all nodes)
\item \code{edge_lengths} a list of length \code{pL},
each element is a numeric vector of edge lengths from the root node
to the leaf. It is computed based on \code{E(mytree)$weight}. It is \code{NULL}
if \code{E(mytree)$weight} is \code{NULL}
\item \code{h_pau} a numeric vector of length \code{p}; each value is
the edge length from u to its parent (if u is a root node, then the value is 1).
This vector by default is all \code{1}s. If \code{weighted_edge=TRUE}, \code{h_pau}
is set to \code{E(mytree)$weight}, the input edge weights.
\item \code{v_units} (redundant - identical to \code{leaf_ids})
a vector of length equal to the total number of rows in \code{Y};
each element is an integer between \code{1} and \code{pL},
indicating which leaf does the observation belong to.
\item \code{subject_id_list} a list of length \code{p}; each element is a vector of
subject ids
that are in the leaf descendants of node \code{u} (internal or leaf node)
\item \code{ord} the permutation to order the original rows to produce the final
ordering of the rows of \code{Y}.
}
}
\description{
NB: currently this minimally built; need some checking functions
}
